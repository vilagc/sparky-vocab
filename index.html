<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vocab Spark - AI Vocabulary Tutor</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Google Font: Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Load Lucide icons -->
    <script src="https://unpkg.com/lucide-react@latest/dist/umd/lucide.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom scrollbar for chat */
        #chat-window::-webkit-scrollbar {
            width: 6px;
        }
        #chat-window::-webkit-scrollbar-track {
            background: #f1f5f9; /* cool-gray-100 */
        }
        #chat-window::-webkit-scrollbar-thumb {
            background: #94a3b8; /* cool-gray-400 */
            border-radius: 3px;
        }
        #chat-window::-webkit-scrollbar-thumb:hover {
            background: #64748b; /* cool-gray-500 */
        }
        /* Styling for the speaker button */
        .speaker-btn {
            cursor: pointer;
            color: #64748b; /* cool-gray-500 */
            transition: color 0.2s ease;
        }
        .speaker-btn:hover {
            color: #1e3a8a; /* blue-800 */
        }
        .speaker-btn.playing {
            color: #2563eb; /* blue-600 */
        }
    </style>
</head>
<body class="bg-slate-100 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-2xl bg-white shadow-2xl rounded-2xl flex flex-col" style="height: 80vh;">
        <!-- Header -->
        <header class="bg-blue-700 text-white p-4 rounded-t-2xl flex items-center space-x-3 shadow-lg">
            <div class="w-12 h-12 bg-white rounded-full flex items-center justify-center">
                <!-- Sparky Icon -->
                <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="#1d4ed8" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-sparkles"><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M19 17v4"/><path d="M3 5h4"/><path d="M17 19h4"/></svg>
            </div>
            <div>
                <h1 class="text-xl font-bold">Sparky - Your Vocabulary Tutor</h1>
                <p class="text-sm text-blue-100">Ready to level up your word power!</p>
            </div>
        </header>

        <!-- Chat Window -->
        <div id="chat-window" class="flex-1 p-6 overflow-y-auto space-y-4 bg-slate-50">
            <!-- Messages will be injected here by JavaScript -->
        </div>

        <!-- Loading Indicator -->
        <div id="loading" class="p-6 hidden flex items-center space-x-2">
            <div class="w-3 h-3 bg-slate-400 rounded-full animate-bounce" style="animation-delay: -0.3s;"></div>
            <div class="w-3 h-3 bg-slate-400 rounded-full animate-bounce" style="animation-delay: -0.15s;"></div>
            <div class="w-3 h-3 bg-slate-400 rounded-full animate-bounce"></div>
        </div>

        <!-- Input Area -->
        <div class="p-4 border-t border-slate-200 bg-white rounded-b-2xl">
            <div class="flex items-center space-x-3">
                <input type="text" id="userInput" class="flex-1 border border-slate-300 rounded-xl px-4 py-3 focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Type your word here...">
                <button id="sendButton" class="bg-blue-600 text-white rounded-xl p-3 hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:bg-slate-400">
                    <!-- Send Icon -->
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-send-horizontal"><path d="m3 3 3 9-3 9 19-9Z"/><path d="M6 12h16"/></svg>
                </button>
            </div>
        </div>
    </div>

    <script>
        const chatWindow = document.getElementById('chat-window');
        const userInput = document.getElementById('userInput');
        const sendButton = document.getElementById('sendButton');
        const loadingIndicator = document.getElementById('loading');
        
        // This is the persona for our AI tutor, Sparky.
        const systemPrompt = `You are Sparky, a friendly and encouraging vocabulary tutor for middle school students. Your goal is to help them understand new vocabulary words without ever giving them the direct definition.
        Your rules are strict:
        1.  **NEVER give the answer directly.** Do not provide definitions.
        2.  **Check for ambiguity.** If a word has multiple common meanings (like 'fast' or 'bat'), your first step is to ask a simple clarifying question (e.g., "Do you mean 'fast' as in 'running quickly' or 'fast' as in 'not eating'?").
        3.  **ALWAYS ask leading questions.** Guide the student to discover the meaning themselves.
        4.  **Use metaphors and analogies.** Relate the vocabulary word to real-life scenarios a middle schooler would understand.
        5.  **Detect knowledge gaps.** If a student seems confused about a concept in your explanation, pause and help them understand that background concept first before returning to the main vocabulary word.
        6.  **Keep your tone upbeat, positive, and a little playful.** Use emojis sparingly and appropriately.
        7.  **Start the conversation by introducing yourself** and explaining how you'll help (withoutmentioning you are a computer or program), then ask them for their first word.
        8.  Your responses should be concise, easy to read, and **ALWAYS under 5 sentences long.**
        9.  **ONLY ask one question per response.**
        10. **Do not call yourself an AI,** a computer, or a robot. You are just "Sparky".
        11. **Do not use sparkle emojis (like 'âœ¨').**
        12. **When you mention the main vocabulary word the student is learning, wrap it in <strong> tags (like <strong>ambiguous</strong>) to make it bold.**
        13. **Confirm understanding.** Once you feel the student understands the word, ask them to write out the definition *in their own words*. After they do, you can confirm their understanding (or gently correct them) before asking if they're ready for a new word.`;

        let chatHistory = [{
            role: "user",
            parts: [{ text: systemPrompt }]
        }];

        // Audio state
        let currentAudio = null;
        let currentPlayingButton = null;

        /**
         * Converts a Base64 string to an ArrayBuffer.
         */
        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        /**
         * Converts raw PCM16 audio data to a WAV Blob.
         */
        function pcmToWav(pcmData, sampleRate) {
            const header = new ArrayBuffer(44);
            const view = new DataView(header);
            const pcmLength = pcmData.byteLength;
            const wavLength = pcmLength + 36; // 44 bytes header - 8 bytes for "RIFF" and "WAVE"

            // RIFF chunk descriptor
            view.setUint32(0, 0x52494646, false); // "RIFF"
            view.setUint32(4, wavLength, true);   // Total file size - 8
            view.setUint32(8, 0x57415645, false); // "WAVE"
            
            // fmt sub-chunk
            view.setUint32(12, 0x666d7420, false); // "fmt "
            view.setUint32(16, 16, true);          // Sub-chunk size (16 for PCM)
            view.setUint16(20, 1, true);           // Audio format (1 for PCM)
            view.setUint16(22, 1, true);           // Number of channels (1)
            view.setUint32(24, sampleRate, true);  // Sample rate
            view.setUint32(28, sampleRate * 2, true); // Byte rate (SampleRate * NumChannels * BitsPerSample/8)
            view.setUint16(32, 2, true);           // Block align (NumChannels * BitsPerSample/8)
            view.setUint16(34, 16, true);          // Bits per sample (16)

            // data sub-chunk
            view.setUint32(36, 0x64617461, false); // "data"
            view.setUint32(40, pcmLength, true);   // Sub-chunk 2 size (data size)

            return new Blob([header, pcmData], { type: 'audio/wav' });
        }


        /**
         * Stops any currently playing audio and resets its button.
         */
        function stopCurrentAudio() {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
            }
            if (currentPlayingButton) {
                currentPlayingButton.classList.remove('playing');
                // Restore speaker icon
                currentPlayingButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-volume-2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>`;
                currentPlayingButton = null;
            }
        }

        /**
         * Fetches and plays the audio for a given text.
         */
        async function speakText(text, button) {
            if (currentPlayingButton === button) {
                // If clicking the same button, stop playback
                stopCurrentAudio();
                return;
            }

            // Stop any other audio that might be playing
            stopCurrentAudio();

            // Set this button as the new playing button
            currentPlayingButton = button;
            button.classList.add('playing');
            // Change to loading/playing icon
            button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-loader-2 animate-spin"><path d="M21 12a9 9 0 1 1-6.219-8.56"/></svg>`;

            const apiKey = "AIzaSyCxHmXLOBKPKIWVTeMopFU3qMWthYDfuso"; // API Key Added
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{
                    parts: [{ text: `Say in a friendly, encouraging tone: ${text}` }]
                }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: "Puck" } // A friendly, upbeat voice
                        }
                    }
                },
                model: "gemini-2.5-flash-preview-tts"
            };

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`TTS API error! Status: ${response.status}`);
                }

                const result = await response.json();
                const part = result?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                    const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                    const sampleRate = sampleRateMatch ? parseInt(sampleRateMatch[1], 10) : 24000; // Default to 24kHz
                    
                    const pcmData = base64ToArrayBuffer(audioData);
                    const pcm16 = new Int16Array(pcmData);
                    const wavBlob = pcmToWav(pcm16, sampleRate);
                    const audioUrl = URL.createObjectURL(wavBlob);
                    
                    currentAudio = new Audio(audioUrl);
                    
                    // You can adjust this value to speed up (e.g., 1.1) or slow down (e.g., 0.9)
                    currentAudio.playbackRate = 1.0; 
                    
                    currentAudio.play();

                    // Change icon to 'playing'
                    button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pause"><rect width="4" height="16" x="6" y="4"/><rect width="4" height="16" x="14" y="4"/></svg>`;

                    currentAudio.onended = () => {
                        stopCurrentAudio();
                    };
                } else {
                    throw new Error("Invalid audio data received from API.");
                }

            } catch (error) {
                console.error("Error playing audio:", error);
                addMessage("Oops! My speaker just fizzled out. Please try again.", "sparky");
                stopCurrentAudio();
            }
        }


        /**
         * Adds a message to the chat window.
         * @param {string} text The message content.
         * @param {'user' | 'sparky'} role The sender of the message.
         */
        function addMessage(text, role) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `flex ${role === 'user' ? 'justify-end' : 'justify-start'} w-full`;

            let content = '';
            
            // Sanitize text to prevent HTML injection, but allow bold tags
            let sanitizedText = text.replace(/&/g, "&amp;")
                                  .replace(/</g, "&lt;")
                                  .replace(/>/g, "&gt;");
            
            // Selectively re-allow <strong> and <b> tags
            sanitizedText = sanitizedText.replace(/&lt;strong&gt;/g, '<strong>').replace(/&lt;\/strong&gt;/g, '</strong>');
            sanitizedText = sanitizedText.replace(/&lt;b&gt;/g, '<b>').replace(/&lt;\/b&gt;/g, '</b>');

            if (role === 'user') {
                content = `
                    <div class="bg-blue-600 text-white p-3 rounded-xl max-w-lg shadow">
                        ${sanitizedText}
                    </div>
                `;
            } else {
                // Sparky's message with a speaker button
                content = `
                    <div class="bg-slate-200 text-slate-800 p-3 rounded-xl max-w-lg shadow flex items-start space-x-2">
                        <div class="flex-1">${sanitizedText}</div>
                        <button class="speaker-btn p-1 rounded-full hover:bg-slate-300" onclick="speakText(this.previousElementSibling.innerText, this)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-volume-2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>
                        </button>
                    </div>
                `;
            }

            messageDiv.innerHTML = content;
            chatWindow.appendChild(messageDiv);
            chatWindow.scrollTop = chatWindow.scrollHeight; // Auto-scroll to bottom
        }

        /**
         * Sends the user's message to the Gemini API and gets a response.
         */
        async function getSparkyResponse(prompt) {
            loadingIndicator.classList.remove('hidden');
            sendButton.disabled = true;
            userInput.disabled = true;
            stopCurrentAudio(); // Stop any audio when a new message is sent

            // Add user prompt to chat history
            chatHistory.push({
                role: "user",
                parts: [{ text: prompt }]
            });

            const apiKey = "AIzaSyCxHmXLOBKPKIWVTeMopFU3qMWthYDfuso"; // API Key Added
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

            const payload = {
                contents: chatHistory,
                // No tools or system instruction needed here as it's part of the history
            };

            // Implement exponential backoff for API retries
            let response;
            let delay = 1000; // start with 1 second
            for (let i = 0; i < 5; i++) { // Retry up to 5 times
                try {
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        break; // Success
                    } else if (response.status === 429 || response.status >= 500) {
                        // If rate limited or server error, wait and retry
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2; // Double the delay
                    } else {
                        // Other client-side errors, don't retry
                        throw new Error(`API request failed with status ${response.status}`);
                    }
                } catch (error) {
                    if (i === 4) { // Last attempt failed
                        throw error;
                    }
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2;
                }
            }
            
            try {
                if (!response.ok) {
                    throw new Error(`API request failed with status ${response.status}`);
                }

                const result = await response.json();
                const candidate = result.candidates?.[0];

                if (candidate && candidate.content?.parts?.[0]?.text) {
                    const sparkyText = candidate.content.parts[0].text;
                    
                    // Add Sparky's response to history
                    chatHistory.push({
                        role: "model",
                        parts: [{ text: sparkyText }]
                    });

                    addMessage(sparkyText, "sparky");
                } else {
                    // Handle cases like safety blocks or empty responses
                    console.error("Invalid response from API:", result);
                    let errorText = "Hmm, my circuits got a little crossed. Could you try asking that again?";
                    if (candidate?.finishReason === "SAFETY") {
                        errorText = "I'm not able to talk about that topic. How about we try another word?";
                    }
                    addMessage(errorText, "sparky");
                    // Remove the user's last message from history if it was problematic
                    chatHistory.pop();
                }

            } catch (error) {
                console.error("Error communicating with API:", error);
                addMessage("Yikes! I think I blew a fuse. Please check the console and try again.", "sparky");
            } finally {
                loadingIndicator.classList.add('hidden');
                sendButton.disabled = false;
                userInput.disabled = false;
                userInput.focus();
            }
        }

        /**
         * Handles the send button click or Enter key press.
         */
        function handleSend() {
            const text = userInput.value.trim();
            if (text) {
                addMessage(text, "user");
                getSparkyResponse(text);
                userInput.value = '';
            }
        }

        // Event Listeners
        sendButton.addEventListener('click', handleSend);
        userInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); // Prevent new line
                handleSend();
            }
        });

        /**
         * Initial welcome message from Sparky.
         */
        async function sendWelcomeMessage() {
            loadingIndicator.classList.remove('hidden');
            
            const apiKey = "AIzaSyCxHmXLOBKPKIWVTeMopFU3qMWthYDfuso"; // API Key Added
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

            const payload = {
                contents: chatHistory
            };
            
            // Implement exponential backoff for API retries
            let response;
            let delay = 1000; // start with 1 second
            for (let i = 0; i < 5; i++) { // Retry up to 5 times
                try {
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        break; // Success
                    } else if (response.status === 429 || response.status >= 500) {
                        // If rate limited or server error, wait and retry
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2; // Double the delay
                    } else {
                        // Other client-side errors, don't retry
                        throw new Error(`API request failed with status ${response.status}`);
                    }
                } catch (error) {
                    if (i === 4) { // Last attempt failed
                        throw error;
                    }
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2;
                }
            }

            try {
                if (!response.ok) throw new Error("API request failed");
                
                const result = await response.json();
                const text = result.candidates[0].content.parts[0].text;
                
                // Add Sparky's intro to history
                chatHistory.push({
                    role: "model",
                    parts: [{ text: text }]
                });
                
                addMessage(text, "sparky");

            } catch (error) {
                console.error("Error getting welcome message:", error);
                addMessage("Hello! I'm Sparky. My circuits are a bit fuzzy right now, but I'm here to help. What's your first word?", "sparky");
            } finally {
                loadingIndicator.classList.add('hidden');
                userInput.focus();
            }
        }

        // Start the app
        sendWelcomeMessage();

    </script>
</body>
</html>

